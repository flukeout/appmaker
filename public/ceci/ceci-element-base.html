<polymer-element name="ceci-element-base">
  <template>
    <content></content>
    <audio></audio>
  </template>
  <script>
    var L10n = {
      get: function(v) { return v; }
    };

    require(['l10n'], function (lib) { L10n = lib; });

    var DEFAULT_CHANNEL = 'blue';

    // Mouse/touch events that need to be routed properly
    var customListenerMap = {
      'on-ceci-pressdown': { eventName: 'ceci-pressdown', mobile: 'touchstart', desktop: 'mousedown' },
      'on-ceci-pressup': { eventName: 'ceci-pressup', mobile: 'touchend', desktop: 'mouseup' }
    };

    // Create a query selector based on the map above, like '[on-ceci-pressdown],[on-ceci-pressup]'.
    var customListenerQuerySelector = Object.keys(customListenerMap).map(function (m) {
      return '[' + m + ']';
    }).join(',');

    function processDefinition (element) {
      var definitionJSON = window.CeciDefinitions[element.localName];

      if (definitionJSON) {
        // Defaults for safety and efficiency :) !
        definitionJSON.tags = definitionJSON.tags || [];
        definitionJSON.thumbnail = definitionJSON.thumbnail || '';
        definitionJSON.listeners = definitionJSON.listeners || {};
        definitionJSON.broadcasts = definitionJSON.broadcasts || {};
        definitionJSON.attributes = definitionJSON.attributes || {};
      }
      else {
        throw new Error("Couldn't find Ceci definition for " + element.localName + ".");
      }

      return definitionJSON;
    }

    function processAttributes (ceciDefinition, attributesDefinitionObject) {
      var result;

      if (!attributesDefinitionObject) return;

      result = {
        listeners: {},
        attributeListeners: {}
      };

      Object.keys(attributesDefinitionObject).forEach(function (attributeName) {
        var attributeDefinition = attributesDefinitionObject[attributeName];

        if (attributeDefinition.listener) {
          var listenerName;

          if (typeof attributeDefinition.listener === 'string') {
            listenerName = attributeDefinition.listener;
          }
          else {
            listenerName = 'set_' + attributeName;
            result.attributeListeners[attributeName] = listenerName;
          }

          result.listeners[listenerName] = {
            description: '(Setter) ' + attributeDefinition.description,
            label: attributeDefinition.label,
            'default': attributeDefinition.defaultListener,
            attribute: attributeName
          };
        }

        if (attributeDefinition.editable) {
          ceciDefinition[attributeName] = {
            description: attributeDefinition.description,
            label: attributeDefinition.label,
            type: attributeDefinition.editable
          };
        }
      });

      return result;
    }

    function processListeners (ceciDefinition, listenersDefinitionObject) {
      var defaultListeners = [];

      if (!listenersDefinitionObject) return defaultListeners;

      Object.keys(listenersDefinitionObject).forEach(function (listenerName) {
        var listenerDefinition = listenersDefinitionObject[listenerName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[listenerName] = listenerDefinition;
        if (!!listenerDefinition['default']) {
          if (listenerDefinition['default'] !== true) {
            channel = listenerDefinition['default'];
          }
          defaultListeners.push({name: listenerName, channel: "a" });
        }
      });

      return defaultListeners;
    }

    function processBroadcasts (ceciDefinition, broadcastsDefinitionObject) {
      var defaultBroadcasts = [];

      if (!broadcastsDefinitionObject) return defaultBroadcasts;

      Object.keys(broadcastsDefinitionObject).forEach(function (broadcastName) {
        var broadcastDefinition = broadcastsDefinitionObject[broadcastName];
        var channel = DEFAULT_CHANNEL;
        ceciDefinition[broadcastName] = broadcastDefinition;
        if (!!broadcastDefinition['default']) {
          if (broadcastDefinition['default'] !== true) {
            channel = broadcastDefinition['default'];
          }
          defaultBroadcasts.push({name: broadcastName, channel: "a" });
        }
      });

      return defaultBroadcasts;
    }

    Polymer('ceci-element-base', {
      eventListeners : [],
      sounds : {}, // should keep a reference to the object that plays it, not just the buffer yeah?
      _sounds : {},
      audiotype : "",
      playingSound : {},
      pauseSound : function(sound){
        // if(this.playingSound[sound]) {
          // this.playingSound[sound].pause();
        // }
      },
      playSound : function(soundName,volume){
        // console.log(this._sounds);

        var that = this;

        if(this._sounds[soundName] && this.ctx){

          if(isNaN(parseFloat(volume))) {
            volume = 1;
          } else {
            volume = parseFloat(volume);
          }

          if(volume > 1) { volume = 1; }
          if(volume < 0) { volume = 0; }



          var sound = this._sounds[soundName];
          console.log(sound);

          sound.gainNode.gain.value = volume;

          if(sound.type === "element") {
            console.log(sound.el);
            if(sound.status === "playing") {
              sound.el.pause();
              sound.el.currentTime = 0;
            }
            sound.el.play();
          }

          if(sound.type === "buffer"){
            console.log("playing buffer sound");
            sound.source = that.ctx.createBufferSource();

            sound.source.addEventListener("ended",function(){
              console.log("Stopped");
              sound.status = "stopped";
            });

            sound.source.onended = function(){};

            sound.source.connect(that._sounds[soundName].gainNode);
            sound.source.buffer = that._sounds[soundName].buffer;
            sound.source.loop = false;
            sound.source.start(0);


          }

          // Change status to playing
          sound.status = "playing";

        }
      },
      loadSound : function(soundName,soundPath){
        var that = this;

        if(this.ctx){

          var xhr = new XMLHttpRequest();
          xhr.open("GET", this.resolvePath(soundPath), true);

          xhr.responseType = "arraybuffer";
          var that = this;

          that._sounds[soundName] = {};
          that._sounds[soundName].name  = soundName;
          that._sounds[soundName].path  = soundPath;
          that._sounds[soundName].status  = "stopped";
          that._sounds[soundName].gainNode  = that.ctx.createGain();
          that._sounds[soundName].gainNode.connect(that.ctx.destination);

          // var audioEl = that.shadowRoot.querySelector("audio");
          // console.log("gonna add this guy");
          // console.log(audioEl);
          // var context = new window.AudioContext;
          // context.createMediaElementSource(audioEl);


          //If not, make it into an audio element source
          xhr.onerror = function(e) {

            var audioEl = new Audio();

            // audioEl.src = soundPath;
            audioEl.src = "/bark.mp3";
            that._sounds[soundName].el = audioEl;
            console.log("Before");
            that._sounds[soundName].source = that.ctx.createMediaElementSource(audioEl);
            console.log("After");

            that._sounds[soundName].source.connect(that._sounds[soundName].gainNode);
            that._sounds[soundName].type  = "element";


            that._sounds[soundName].el.addEventListener("ended",function(){
              console.log("element sound stopped");
              that._sounds[soundName].status = "stopped";
            });

          };

          //If it's able to load the URL, make it into a buffer source
          xhr.onload = function () {
            if (xhr.response.byteLength) {
              that.ctx.decodeAudioData(xhr.response, function(data) {
                that._sounds[soundName].type = "buffer";
                that._sounds[soundName].buffer  = data;
              },
              function (e) {
                console.error('Error decoding the audio buffer.', arguments);
              });
            }

          };

          xhr.send();
        }


      },
      ready: function () {
        this._sounds = {};
        this.eventListeners = [];
        if (this.ceci) return;
        this.addedCustomListeners = false;

        var that = this;

        //Use the app's audio context if it's ready
        var app = document.querySelector("ceci-app");
        if(app){ this.ctx = app.Audiocontext; }

        this.ceci = {
          broadcasts: {},
          listeners: {},
          editables: {},
          attributes: {}
        };

        this.ceciDefinition = processDefinition(this);

        if (!this.ceciDefinition) {
          console.error('Ceci definition required for ' + this.localName);
          return;
        }

        var attributeResults = processAttributes(this.ceci.editables, this.ceciDefinition.attributes || {});

        Object.keys(attributeResults.attributeListeners).forEach(function (attributeName) {
          var listenerName = attributeResults.attributeListeners[attributeName];
          that[listenerName] = function (value) {
            that[attributeName] = value;
          };
        });

        Object.keys(this.ceciDefinition.listeners).forEach(function (listenerDefinitionName) {
          attributeResults.listeners[listenerDefinitionName] = that.ceciDefinition.listeners[listenerDefinitionName];
        });

        this._defaultListeners = processListeners(this.ceci.listeners, attributeResults.listeners);
        this._defaultBroadcasts = processBroadcasts(this.ceci.broadcasts, this.ceciDefinition.broadcasts);

        this.ceci.thumbnail = this.ceciDefinition.thumbnail;
        this.ceci.tags = this.ceciDefinition.tags || [];
        this.ceci.attributes = this.ceciDefinition.attributes || {};
        this.ceci.name = this.gettext(this.localName) || this.ceciDefinition.name || this.localName;
        this.localized();
        this.fire('CeciElementReady');
      },
      applyDefaults: function () {
        // This code should never be moved to "attached" or be applied automatically when
        // the element is added to the page. It must be run explicitly by an external function,
        // since it's hard to detect whether or not this element is really "new" (e.g. someone
        // just added it to their app), or was created from a loaded app. In the latter case,
        // defaults should not be applied. Only when an element is new do we want this function
        // to run.

        var that = this;
        var map = document.querySelector("ceci-channel-map");
        var channel;
        var used = []; //Used channels so we don't use the same one for broadcasting and listening

        this._defaultListeners.forEach(function (d) {
          if (!that.querySelector('ceci-listen[for="' + d.name + '"]')) {
            channel = map.getFreeChannel("listener");
            that.setListener(d.name, channel);
            used.push(channel);
          }
        });

        this._defaultBroadcasts.forEach(function (d) {
          if (!that.querySelector('ceci-broadcast[from="' + d.name + '"]')) {
            channel = map.getFreeChannel("broadcast",used);
            that.setBroadcast(d.name, channel);
          }
        });
      },
      broadcast: function (name, data) {
        var broadcastElement = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcastElement) {
          var broadcastDetails = { channelName : broadcastElement.on, from : name};
          broadcastElement.fire(data);
        }
      },
      showContainingCard: function () {
        var potentialCard = this.parentNode;

        while (potentialCard && potentialCard.localName !== 'ceci-card') {
          potentialCard = potentialCard.parentNode;
        }

        if (potentialCard) {
          potentialCard.show();
        }
      },
      setListener: function (name, channel) {
        var entry = this.ceci.listeners[name];

        if (entry) {
          var listener = this.querySelector('ceci-listen[for="' + name + '"]');
          if (!listener) {
            listener = document.createElement('ceci-listen');
            this.appendChild(listener);
          }

          listener.setAttribute('on', channel);
          listener.setAttribute('for', name);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'listen'}});
        }
        else {
          console.error('No listener definition found for "' + name + '".');
        }
      },
      setBroadcast: function (name, channel) {
        var entry = this.ceci.broadcasts[name];
        if (entry) {
          var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
          if (!broadcast) {
            broadcast = document.createElement('ceci-broadcast');
            this.appendChild(broadcast);
          }
          broadcast.setAttribute('on', channel);
          broadcast.setAttribute('from', name);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: channel, type: 'broadcast'}});
        }
        else {
          console.error('No broadcast definition found for "' + name + '".');
        }
      },
      removeListener: function (name) {
        var listen = this.querySelector('ceci-listen[for="' + name + '"]');
        if (listen) {
          this.removeChild(listen);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'listen'}});
        }
      },
      removeBroadcast: function (name) {
        var broadcast = this.querySelector('ceci-broadcast[from="' + name + '"]');
        if (broadcast) {
          this.removeChild(broadcast);
          this.fire('CeciChannelUpdated', {detail: {name: name, channel: null, type: 'broadcast'}});
        }
      },
      attached: function () {
        if(!this.addedCustomListeners) {
          this.touchEnabled = 'ontouchstart' in document.documentElement;
          var els = this.shadowRoot.querySelectorAll(customListenerQuerySelector);
          Array.prototype.forEach.call(els, this.addCustomListener.bind(this));
          this.addedCustomListeners = true;
        }
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: this}));
      },
      addCustomListener: function(el, listener){
        // Loop over the on-ceci-* listener types to see which one applies to this element
        var that = this;
        Object.keys(customListenerMap).forEach(function (listener) {
          if (!el.hasAttribute(listener)) return;

          // If there is a valid map entry, grab it
          var mapEntry = customListenerMap[listener];

          if(mapEntry) {
            // Fire an event directly at the element with the on-ceci-* attribute
            el.addEventListener(mapEntry[that.touchEnabled ? 'mobile' : 'desktop'], function(e){
              // Emit an event without the "on-" prefix, to let Polymer's template syntax sugar do the rest
              el.dispatchEvent(new CustomEvent(listener.substr(3), {bubbles: true, detail: this}));
            });
          }
        });
      },
      domReady: function () {
        document.dispatchEvent(new CustomEvent('CeciElementAdded', {bubbles: true, detail: this}));
      },
      gettext: function (keyname) {
        return L10n.get(keyname);
      },
      localized: function () {
        var attributes = this.ceci.attributes;
        for(var attribute in attributes) {
          if (attributes.hasOwnProperty(attribute)) {

            // Check to see if attribute is still default value. Otherwise, skip localization.
            if (this[attribute] === this._instanceAttributes[attribute]) {
              this[attribute] = this.gettext(this.localName + "/attributes/" + attribute) || this[attribute];
            }
          }
        }
      }
    });
  </script>
</polymer-element>
